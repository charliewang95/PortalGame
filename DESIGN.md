Design
====
Charlie Wang (qw42)
9/14/16

1. My ultimate goal for this game is to let the players experience fun and let them use their brains. With the difficulty increasing with each level, I want the players to feel challenged step by step. To achieve this, I designed three elementary levels to teach the players the basic rules of this puzzle game -- they can transport themselves through portals, but each time they do so, the doors of the same color changes state (open and close), and their goal is to reach the destination. To achieve the rules, I implemented two classes, _Door_ and _Portal_, which are interconnected and can call each other. To set up the map, use some arraylists to store rectangle objects (maybe upgraded later). The most difficult part is the level design -- thinking of a set up that requires some technique. The maps are mostly squares for convenience, and I spent approximately two days on each map to make sure each level takes 1-2 more steps than the previous level.

2. The current game has an important feature -- when the player passes through a portal, the corresponding door opens (or closes). Another incident that can happen is that when the player passes through a portal, a piece of ground disappears permanently. Because there's no such concept as "ground" in the current game, we need to create a new _Ground_ Class. Each _Ground_ Object will contain a shape (likely a rectangle). Like I did with the _Door_ Object, I can add a method _addGround_ to the Portal class, and whenever I want to associate a _Ground_ with a _Portal_, I call this method. Unlike _Door_ objects, the toggle method for _Ground_ will be made along with a flag so that when it's been toggled once, it cannot be toggled back (stay transparent). Also, I will not track how many times the _Ground_ object is toggled when reseting, but will reuse the flag I used above.  

3. In the final version, I put all the level setup methods in the _ImpasseGame_ class. At some point during the project, I wanted to make a separate class for each level and make _ImpasseGame_ an interface. This will make the _ImpasseGame_ class much shorter. This is the pro. However, in this case, the _ImpasseMain_ class has to initialize each class once, which is more work than initializing a single class multiple times. Furthermore, since a lot of things in each level are similar (like level title, hint text, etc), putting them into one class can save a lot of duplicated code, and after refinement and factoring, each level's setup method is not that long. Also, making new levels becomes easier this way, since I can just add a new method. So in the end I gave up the "separate class" idea and keep the original one. Secondly, my current "Go to next level" function is by pressing a button after completing a level (or use cheats, of course). This approach asks the player to do action to go to the next level, so the player can replay this level to find new solutions if they want. However, the button approach (the one I implemented) can be buggy sometimes. If there is another button on the scene, they sometimes have conflicts. This is a problem I have not overcome. Another approach would be going to the next level automatically when the player completes this level. In this way, the player cannot replay this level, but it will increase the fluency of the game play. Because of this reason, I think the second approach is better, but I haven't been able to think of a good way to achieve this. 
 
4. At the beginning, the _Door_ class was inside the _Portal_ class as a subclass. But as I add new features, a door object might be associated with a list of portals, which means these portals are on the door itself. When the door opens, the portals in this list toggles visibility as well. This is why in the end Door and Portal are made into two different classes - to avoid conflict (e.g. a subclass calls its parent class). Another ambiguity in the game is the position and thickness of the portals. If I place them on a wall, according to the algorithm to check collision, the player can pass through the portal from the other side, which is unexpected. I used two methods -- add thickness to the wall, and change the shape of the door to eliminate theis ambiguity.
